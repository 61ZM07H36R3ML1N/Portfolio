const Document = require('vertex-camo').Document
const path = require('path')
const fs = require('fs')
const TaskMgr = require('./TaskMgr')

const BASE_DIR = __dirname + '/../../../../'
const TMP_DIR = process.env.TMP_DIR || '/tmp'
const LOCAL_DIR = path.join(BASE_DIR, TMP_DIR)
const defaultMethods = ['constructor', 'get', 'getById', 'post', 'put', 'delete']
let _TURBO_ENV, _TURBO_API_KEY, _turbo = null

class Controller {
	constructor(schema, env){
		this._schema = schema // Job, Post, Profile, etc

		_turbo = require('turbo360')({site_id: env.TURBO_APP_ID})
		_TURBO_API_KEY = env.TURBO_API_KEY
		_TURBO_ENV = env.TURBO_ENV

		this.hooks = {
			find: (collectionName) => {
				return new Promise((resolve, reject) => {
					// console.log('FIND HOOK: ')
					Controller.checkCollectionDB(collectionName)
					.then(data => {
						resolve(data)
					})
					.catch(err => {
						reject(err)
					})
				})
			},
			save: (collectionName) => {
				// Places collectionName in a sync object which "queues" collections
				// to be synced after 5-second delay. This basically acts as a debounce
				// mechanism to prevent a series of save() requests from syncing to S3
				// a bunch of times repeatedly:
				return new Promise((resolve, reject) => {
					// console.log('SAVE HOOK: ')

					// collection is already waiting to be synced,
					// don't add again and prevent task from posting:
					if (TaskMgr.sync[collectionName]) {
						resolve()
						return
					}

					TaskMgr.sync[collectionName] = true
					const now = new Date()
					TaskMgr.queue.push(now.toString()+' - sync collection: '+collectionName)

					// TODO: create scheduled task on cloudwatch,
					// data stream on kinesis, SQS or SNS?
					resolve()
				})
			}
		}

		const props = Object.getOwnPropertyNames(Object.getPrototypeOf(this))
		const _this = this
		props.forEach(funcName => {
			// this is a custom method added by developer:
			if (typeof this[funcName] !== 'function')
				return

			if (defaultMethods.indexOf(funcName) > -1){
				if (funcName=='constructor')
					return

				const originalFunc = this[funcName]
				if (funcName=='get' || funcName=='getById'){
					this[funcName] = async function(){
						// console.log('TEST!!!! '+JSON.stringify(...arguments))
						const data = await _this.hooks.find(_this.collectionName())
						return originalFunc(...arguments)
					}
				}
				else {
					this[funcName] = async function(){
						// console.log('TEST!!!! '+JSON.stringify(...arguments))
						const payload = await originalFunc(...arguments)
						if (_TURBO_ENV !== 'prod')
							return payload

						try {
							const a = await _this.hooks.save(_this.collectionName())
							return payload
						}
						catch(err){
							return payload
						}
					}
				}

				return
			}

			// console.log('CONSTRUCTOR FUNCTION: ' + funcName)
			const originalFunc = this[funcName]
			this[funcName] = async function() {
				// console.log('ARGUMENTS: '+JSON.stringify(arguments))
				const data = await _this.hooks.find(_this.collectionName())
				const payload = await originalFunc(...arguments)

				if (_TURBO_ENV !== 'prod')
					return payload

				try {
					const a = await _this.hooks.save(_this.collectionName())
					return payload
				}
				catch(err){
					return payload
				}
			}
		})
	}

	static instance() {
		return new this()
	}

	static checkCollectionDB(collectionName) {
		const collectionFilePath = (_TURBO_ENV=='dev') ? LOCAL_DIR+'/'+collectionName+'.db' : TMP_DIR+'/'+collectionName+'.db'

		return new Promise((resolve, reject) => {
			_turbo.checkCollectionFile(collectionName, collectionFilePath)
			.then(data => { // load collection file from backing store if necessary
				return (data.found) ? null : _turbo.loadCollection(collectionName, collectionFilePath, _TURBO_API_KEY)
			})
			.then(data => {
				resolve(data)
			})
			.catch(err => {
				reject(err)
			})
		})
	}

	static syncCollection(collectionName) {
		const filePath = (_TURBO_ENV=='dev') ? LOCAL_DIR + '/'+collectionName+'.db' : TMP_DIR+'/'+collectionName+'.db'
		return _turbo.syncCollection(collectionName, filePath, _TURBO_API_KEY)
	}

	static parseFilters(params) {
		if (params == null)
			return null

		const filters = {}
		filters['sort'] = (params.sort == 'asc') ? 'timestamp' : '-timestamp'
		delete params['sort']

		filters['limit'] = (params.limit) ? parseInt(params.limit) : 0
		delete params['limit']
		return filters
	}

	// syncs all collections in this.sync object then clears it:
	// syncCollections() {
	// 	const collectionNames = Object.keys(this.sync)
	// 	const promises = collectionNames.map(collectionName => Controller.syncCollection(collectionName))
	// 	Promise.all(promises)
	// 	.then(data => {
	// 		this.sync = {} // reset sync object
	// 	})
	// 	.catch(err => {
	// 		console.log('syncCollections error - '+err)
	// 	})
	// }

	collectionName() {
		return this._schema.collectionName()
	}

	schema() {
		return this._schema.schema()
	}

  	get(params) {
		return null
	}

	getById(id) {
		return null
	}

	post(body) {
		return null
	}

	put(id, params) {
		return null
	}

	delete(id) {
		return null
	}
}

module.exports = Controller
